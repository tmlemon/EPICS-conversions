#!/usr/bin/env python
'''
@author: Tyler Lemon (tlemon)
Date:    2019-04-17

Hall C HV EPICS Backup Restore Python Program

HV-bur.py = Hall C 'HV' EPICS 'B'ack'U'p 'R'estore 'PY'thon program

HV-bur.py uses the pyepics Python module to backup and restore HV PVs for Hall
C. The backup functionality pulls PVs from previously developed CSS-BOY GUIs
for the HV system. The restore function uses backup files generated by this
program to write saved values to PVs. With user's first input arguement, program
can be set to either backup or restore.

HV-bur.py is developed to be called from Hall C HV backup and restore
CSS-BOY GUIs. It can still be run from the command line, but there is very
little error handling.


Command syntax is:

to RESTORE:
python <path>/HV-bur.py restore <path> [file]

<path> is the path where HV-bur.py, backup files, and CSS-BOY OPI files are.
[file] (optional) is name of backup file to restore from. If not used,
        program looks at <path> and finds latest backup file to use for restore.


to BACKUP:
python <path>/HV-bur.py backup <path> [comment]

<path>    is the path where HV-bur.py, backup files, and CSS-BOY OPI files are.
[comment] (optional) is any comment to add to backup file. When running from
           command line, comment should be enclosed in "double quotes".
'''


import sys #used to read in user inputs
from datetime import datetime #used to get date/time of program execution
import time
import os
try:
    import epics #used to call caget_many funciton
except:
    print('ERROR: pyepics not found.')
    sys.exit(1)

startT = time.time()

# Boolean used to tell program to use development IOC rather than real PVs
# Looks at host name to see if it development PC. Add PC to devList to
# automatically run in dev mode when on PC.
import socket
devList = ['dsg-c-linux1.jlab.org']
dev = socket.gethostname() in devList

if dev:
    print('DEV MODE ENABLED (see HV-bur.py code, line 52)')
# Size of sub-arrays used in restore. caput_many seems to have problems with
# arrays larger than 600 PVs, so "size" variable was added to let user change
# sub-array size if it makes a difference in execution time.
size = 500

# Regardless of wheter backup or restore, second input arguement from CSS will
# be the path at which the files to backup will be stored.
path = sys.argv[2]
if path[-1] != '/': path += '/'


# START OF CASE FOR RESTORE FUNCTIONALITY
if sys.argv[1] == 'restore':
    # User can either put in a file to restore from, or leave the control
    # blank in CSS to look in path for latest backup file.
    if sys.argv[3] != 'LATEST':
        savFile = sys.argv[3]
    else:
        fList = os.listdir(path)
        poss = []
        mostRecent = ['','']
        for item in fList:
            if item[-4:] == '.sav':
                check = '_'.join(item[:-4].split('_')[-2:])
                if check > mostRecent[0]:
                    mostRecent = [check,item]
        savFile = mostRecent[1]
    if not os.path.isfile(path+savFile) or savFile[-4:] != '.sav':
        if savFile == '':
            print('ERROR: No file to restore from found in current directory.')
        else:
            print('ERROR: File to restore from must exist.')
        sys.exit(1)

    # opens and reads lines of backup file.
    with open(path+savFile,'r') as f:
        restData = f.readlines()

    # Parses lines of backup file and extracts all PVs for a channel and the
    # value contained in the backup file. Also splits PVs and values into
    # sub-arrays of length "size" (variable from beginning).
    props = ['V0Set','I0Set','SVMax','Rup','RDWn']
    count = 0
    pvs,vals = [],[]
    pvsHold,valsHold = [],[]
    for line in restData:
        if line.strip()[0] not in ['#','']:
            line = line.strip().split('\t')
            chid,crate,slot,channel,group = line[:5]
            basePV = 'hchv'+crate+':'+slot.zfill(2)+':'+channel.zfill(3)+':'
            propSet = line[5:]
            for i,prop in enumerate(propSet):
                count += 1
                if dev:
                    p = 'devIOC:ai'+str(count)
                    v = str(count*2)
                else:
                    p = basePV+props[i]
                    v = float(prop)
                pvsHold.append(p)
                valsHold.append(v)
                if len(pvsHold) >= size:
                    pvs.append(pvsHold)
                    vals.append(valsHold)
                    pvsHold,valsHold = [],[]
    pvs.append(pvsHold)
    vals.append(valsHold)

    # Performs the caput_many function to write all PV values in backup file,
    # earlier stored in sub-arrays, to the PV.
    for q,grp in enumerate(pvs):
        epics.caput_many(grp,vals[q])

    # Prints a restore complete message.
    print('RESTORE FROM\n'+savFile+'\nCOMPLETE')
# END OF RESTORE CASE.




# START OF CASE FOR BACKUP FUNCTIONALITY
elif sys.argv[1] == 'backup':
    #group mapping from old Tcl/Tk system
    groups = ['1','2','3','4','5','7','8','9','11','12','13','14','15','16',\
        '17','18','19','20','21','22','10']
    systems = ['HMS Hodo 1 X','HMS Hodo 1 Y','HMS Hodo 2 X','HMS Hodo 2 Y',\
        'HMS Drift Chambers','HMS Shower Counter A','HMS Shower Counter B',\
        'HMS Cherenkov and Aerogel','SHMS Hodo 1 X','SHMS Hodo 1 Y',\
        'SHMS Hodo 2 X','SHMS Hodo 2 Y','SHMS HGC','SHMS NGC','SHMS Aerogel',\
        'SHMS Preshower','SHMS Shower A','SHMS Shower B','SHMS Shower C',\
        'SHMS Shower D','SHMS Drift Chambers']


    #Checks whether user input a comment.
    if len(sys.argv) >= 4: comment = sys.argv[3]
    else: comment = ''

    #does some nice formatting for user's comment to make sure it wraps nicely
    #in the final backup file.
    if len(comment) > 60:
        cut = []
        last = 0
        for i,word in enumerate(comment.split(' ')):
            if len(' '.join(comment.split(' ')[last:i])) > 60:
                cut.append(i-1)
                last = i-1
        start = 0
        newComm = ''
        for l,item in enumerate(cut):
            if l != 0:
                newComm += '#\t\t\t'+(' '.join(comment.split(' ')\
                    [start:item]))+'\n'
            else:
                newComm += (' '.join(comment.split(' ')[start:item]))+'\n'
            start = item
        newComm += '#\t\t\t'+(' '.join(comment.split(' ')[start:]))+'\n'
        comment = newComm.strip()

    #declares input file (inFile), and path where input file is (path).
    #path will also be where final backup file is stored.
    path = sys.argv[2]
    if path[-1] != '/': path += '/'

    # Looks at any previous backup file for channel ID mapping.
    # if no previous backup file exists, program uses a reference document
    # containing only channel ID mapping information.
    prevSav = []
    for item in os.listdir(path):
        if item[-4:] == '.sav':
            prevSav.append(item)
    if len(prevSav) != 0:
        refFile = sorted(prevSav)[-1]
    else:
        refFile = 'chID_reference.txt'

    with open(path+refFile,'r') as f:    chids = f.readlines()
    ids,maps,groupsTest = [],[],[]
    for item in chids:
        if item.strip()[0] != '#':
            ids.append(item.split('\t')[0])
            maps.append('\t'.join(item.split('\t')[1:4]).strip())
            groupsTest.append(item.split('\t')[1])
    groupsTest = list(set(groupsTest))

    # Creates header for backup file
    date = str(datetime.now())[:str(datetime.now()).find('.')]
    bu = ['# Hall C HV Backup','# Backup created:\t'+date,'# Comment:\t'\
        +comment,'#']
    refLog = []
    for item in systems:
        group = groups[systems.index(item)]
        inFile = item.replace(' ','-')+'-list.opi'

        #properties of each HV channel that will be backed up
        props = ['V0Set','I0Set','SVMax','RUp','RDWn']

        #Reads in input file and stores it as an array where each element is
        # a line in the file.
        with open(path+inFile,'r') as f: data = f.readlines()

        # reads data from input file and extracts PVs in file.
        # Output of code section (pvs) is an array of PV prefixes for each
        # HV channel (ex. hchv2:00:000:)
        pvs = []
        for item in data:
            item = item.strip()
            if item[:9] == '<pv_name>' and item[-10:] == '</pv_name>':
                pv  = item.split('<pv_name>')[1].split('</pv_name>')[0]
                if pv != '' and 'loc://' not in pv:
                    if pv.split(':')[3] in props:
                        pvs.append(':'.join(pv.split(':')[:3]))
        pvs = list(set(pvs))

        # Uses pv list and properties to generate list of all pvs that
        # need backing up. Result of code section (buList) is a 2D list
        # where each element is a list of a channel's properties PVs
        # that need backing up.
        count = 1
        buList = []
        for pv in pvs:
            hold = [pv[4:].split(':')]
            for prop in props:
                if dev:
                    hold.append('devIOC:ai'+str(count))
                else:
                    hold.append(pv+':'+prop)
                count += 1
            buList.append(hold)

        # title of backup file.
        title = inFile.split('/')[-1].replace('-',' ')[:inFile.find\
                ('-list.opi')]

        # Creates header for each detector group.
        bu.append('# Detector: '+title)
        bu.append('# chid\tcrate\tslot\tchannel\tgroup\tV0Set\tI0Set\tSVMax\t\
RUp\tRDwn')

        # performs caget_many function for every list element of buList
        count = 0
        for pv in buList:
            ch = '\t'.join(map(str,map(int,pv[0])))
            chid = ids[maps.index(ch)]
            line = chid+'\t'+ch+'\t'+group+'\t'
            refLog.append(line.strip())
            res = epics.caget_many(pv[1:],as_string=True)
            line += '\t'.join(res)
            bu.append(line.strip())

        bu.append('#')

    #writes data to a text file (file extension .sav can be changed to fit user
    # preferences).
    outFile = 'HV-backup_'+date.replace(' ','_')+'.sav'
    with open(path+outFile,'w') as f:
        for line in bu:
            f.write(line)
            f.write('\n')

    # prints a reponse that CSS looks for to indicate program is done.
    print('BACKUP COMPLETE\n'+outFile+' created.')
# END OF BACKUP CASE

# If for some reason neither backup or restore are entered as arguements,
# this case will catch that and give a message that something bad happened.
else:
    print('ERROR: "backup" or "restore" not selected or other fatal error. \
See CSS Console for more info.')

dT = time.time() - startT
print(dT)
