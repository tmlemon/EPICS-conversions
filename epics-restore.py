#!/usr/bin/env python
'''
author:  Tyler Lemon
date:    2019-03-19

This program works in conjunction with "epics-backup.py" to restore values
to EPICS fields using a backup file.

This main interface of this program to EPICS is through the pyepics module.
The pyepics module uses EPICS channel access to write data stored in
a ".sav" file to the appropriate PVs using the caput_many() function.

For this program to run correctly, the pyepics module is needed.

This program was developed to run from a terminal interface using input
arguements. The usage and command options are below:

python epics-restore.py [<input req file>]

If no input file is entered, program automatically looks in current working
directory for the latest backup file generated by "epics-backup.py".
'''
import subprocess
import sys
import os
from datetime import datetime
import time

try:
    import epics
except:
    print('\nERROR:\tEPICS PYTHON MODULE NOT FOUND.\n\tThe "pyepics" module \
is not installed or cannot be found.\n\t"pyepics" is required to run this \
program.\n')
    sys.exit(0)

startTime = time.time()

# Checks input arguments for file to restore from.
if '-h' not in sys.argv and '--help' not in sys.argv:
    if len(sys.argv)-1 > 0:
        savFile = sys.argv[1]
    else:
        print('\nNo input for save file received.\nProgram will find most \
recent in current working directory to use.\n')
        fList = os.listdir(os.getcwd())
        poss = []
        mostRecent = ['','']
        for item in fList:
            if item[-4:] == '.sav':
                check = '_'.join(item[:-4].split('_')[-2:])
                if check > mostRecent[0]:
                    mostRecent = [check,item]
        savFile = mostRecent[1]
    if not os.path.isfile(savFile) or savFile[-4:] != '.sav':
        if savFile == '':
            print('\nError:\tNo file to restore from found in current working \
directory.\nUse -h or --help for help information.\n')
        else:
            print('\nERROR:\tFile to restore from must exist and have ".sav" \
as its file extension\nUse -h or --help for help information.\n')
        sys.exit(1)
else:
    print('\npython epics-restore.py [<input req file>]\n\nIf no input\
 file is entered, program automatically looks in current working\ndirectory for\
 the latest backup file generated by "epics-backup.py".\n')
    sys.exit(1)

size = 500

print('Running restore...')

with open(savFile,'r') as f:
    restData = f.readlines()
pvGroups = []
valGroups = []
count = 0
progEnd = '|'
total = len(restData)*1.5
hold,hold2 = [],[]
for line in restData:
    line = line.strip()
    if line[0] != '#' and line != '<END>':
        hold.append(line.split('\t')[0])
        out = line.split('\t')[0]+'\t'
        if 'DESC' in line:
            hold2.append(' '.join(line.split('\t')[1:]))
        else:
            hold2.append(line.split('\t')[1])
    if len(hold) >= size:
        pvGroups.append(hold)
        hold = []
    if len(hold2) >= size:
        valGroups.append(hold2)
        hold2 = []
    count = count + 0.5
    sys.stdout.write(('\r{1} |{0}'+progEnd).format(int(25*count/total)*'=',\
        str(int(100*count/total))+'%'))
    sys.stdout.flush()
for i,pvs in enumerate(pvGroups):
    vals = valGroups[i]
    epics.caput_many(pvs,vals)
    count = count + 500
    sys.stdout.write(('\r{1} |{0}'+progEnd).format(int(25*count/total)*'=',\
        str(int(100*count/total)+1)+'%'))
    sys.stdout.flush()
print('\nRestoration complete.')

print('\nVerifying restore...')
okay = True
failed = []
count = 0
total = len(restData)
for n,grp in enumerate(pvGroups):
    vals = valGroups[n]
    check = epics.caget_many(grp,as_string=True)
    count = count + 500
    sys.stdout.write(('\r{1} |{0}'+progEnd).format(int(25*count/total)*'=',\
        str(int(100*count/total)+1)+'%'))
    sys.stdout.flush()
    for i,item in enumerate(check):
        if 'SV' in grp[i]:
            if item == '1':
                item = 'MINOR'
            elif item == '2':
                item = 'MAJOR'
            elif item == '0':
                item = 'NO_ALARM'
        if item != vals[i]:
            okay = False
            failed.append(grp[i])

if not okay:
    print('\nERROR:\tRESTORE VERIFICATION FAILED.\n\t'+str(len(failed))+' PVs \
unable to be restored.\n')
elif okay:
    print('\nVerification complete.\n\nRestore successful.')
else:
    print('\nERROR:\t SOMETHING UNEXPECTED HAPPENED.\n\tAn error occured that \
was not forseen ever happeneing and was not included in any error handling.')

# calculates and prints time it took to run program
runDuration = round(time.time() - startTime,2)
hours = str(int(runDuration/3600))
minutes = str(int((runDuration%3600)/60)).zfill(2)
seconds = str(int((runDuration%3600)%60)).zfill(2)
print('\nProgram complete in '+hours+':'+minutes+':'+seconds)
